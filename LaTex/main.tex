\documentclass[bachelor, german]{algothesis}
% possible types: bachelor, master, zula (seminar, practical)
% Für Seminararbeiten und Praktikumsberichte die Vorlage my-seminar-praktikum.tex verwenden!
% possible languages: english, german

\usepackage[utf8]{inputenc}
\usepackage{svg}
\usepackage{hyperref}
\usepackage{xtab}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{caption}
\usepackage{algpseudocode}
\usepackage{booktabs} 
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{float}
\usepackage[dvipsnames]{xcolor}


\captionsetup[figure]{name=Fig.}
\addto\captionsenglish{
    % Second argument is singular, third is plural
    \crefname{figure}{figure}{figure}
    \Crefname{Figure}{Figure}{Figure}
    \crefname{table}{table}{table}
    \Crefname{Table}{Table}{Table}
    \crefname{chapter}{chapter}{chapter}
    \Crefname{Chapter}{Chapter}{Chapter}
}
\graphicspath{{figures/}}

\title{Simultane Pfadzeichnungen auf dem Gitter} % Geben Sie hier den Titel Ihrer Arbeit an.

\author{Timur Sultanov} % Geben Sie Ihren Namen an.

\newcommand{\abgabedatum}{19. Mai 2025} % Hier wird das Abgabedatum angepasst

\supervisors{% Geben Sie die Namen aller Betreuenden an, getrennt durch das Makro '\and'
Jun.-Prof.\ Dr.\ Philipp Kindermann \and
Prof.\ Dr.\ Stefan Näher} 


\begin{document}


\begin{abstract}
Diese Arbeit beschäftigt sich mit der Modellierung und Optimierung von 2 Graphen auf der gleichen Knotenmenge auf einem zweidimensionalen Gitter. Ziel ist es, zwei Hamiltonpfade in einem Gitter so einzubetten, dass sie sich nicht selbst schneiden und gleichzeitig möglichst wenige Gitterkanten nutzen. Zu diesem Zweck wurde ein lineares Optimierungsmodell formuliert, das sowohl die Pfade selbst als auch deren Überlappung über Variablen und Nebenbedingungen abbildet. Zur Validierung wurde ein Python-Skript entwickelt, das automatisiert Testfälle erzeugt und die Einhaltung der Modellrestriktionen überprüft.\newline 
Die experimentelle Evaluation zeigt, dass das Modell für kleinere Instanzen mit wenigen Knoten und geringer Gittergröße effizient Lösungen berechnet. Mit zunehmender Knotenzahl und Gitterdimension steigen jedoch sowohl die Modellkomplexität als auch die Rechenzeiten stark an. Insbesondere ab etwa 12 Knoten ist das Modell in der Praxis nicht mehr anwendbar, da die Laufzeit sehr schnell wächst und sich stark zwischen einzelnen Testfällen unterscheidet. Eine detaillierte Analyse zeigt, dass diese Varianz nicht allein durch einfache Metriken wie Pfadlänge oder Überlappung erklärbar ist, sondern stark von der strukturellen Komplexität der resultierenden Einbettung abhängt.\newline 
Die Arbeit schließt mit einer Diskussion möglicher Optimierungsansätze sowie einem Ausblick auf potenzielle Erweiterungen des Modells, etwa für mehr als zwei Pfade oder spezifische Einbettungsanforderungen. Insgesamt zeigt sich, dass das Modell eine robuste Grundlage für strukturierte Pfadeinbettung darstellt – jedoch nur für moderat große Instanzen praktisch einsetzbar ist
\end{abstract}

\thesistableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Einleitung}
\section{Motivation und Relevanz des Themas}
Das \emph{Simultaneous Embedding} behandelt die gleichzeitige Visualisierung mehrerer Graphen auf derselben Knotenmenge. Insbesondere wenn sich diese gemeinsamen Teilstrukturen nur in einer Kante oder in wenigen Pfaden unterscheiden, ist eine konsistente Darstellung essentiell, um Unterschiede direkt zu erkennen und zu analysieren. In vielen Szenarien ist es notwendig, mehrere zusammenhängende Strukturen gleichzeitig und ohne visuelle Konflikte abzubilden, um deren Beziehungen und Interaktionen besser nachvollziehbar zu machen. Typische Anwendungsfelder sind nach \cite{Handbook}:
\begin{itemize}
  \item \textbf{Schaltkreisdesign:} Beim Entwurf integrierter Schaltkreise (ICs) müssen zahlreiche Leitungsverbindungen auf kleinstem Raum untergebracht werden. Jeder Pfad entspricht dabei einer elektrischen Verbindung, die auf dem Chip realisiert werden muss. Eine platzsparende Einbettung hilft, die Fläche des Chips zu minimieren, was sowohl Produktionskosten als auch Signalverzögerungen und Energieverbrauch reduziert.
  \item \textbf{Netzwerkplanung:} Beim Vergleich alternativer Verbindungsstrukturen - etwa bei Verkehrs- oder Kommunikationsnetzen - erlaubt die simultane Darstellung mehrerer Routen eine direkte Analyse von Engpässen, Redundanzen und Alternativen, wodurch fundierte Planungsentscheidungen getroffen werden können.
  \item \textbf{Soziale Netzwerke:} Bei der Visualisierung von sozialen Netzwerken, in denen Benutzer durch Kanten (Freundschaften, Beziehungen, Interaktionen) verbunden sind, kann eine simultane Einbettung genutzt werden, um verschiedene Gruppen von Nutzern oder Communitys nebeneinander darzustellen. Dadurch können interessante Strukturen wie Cluster, Gemeinschaften und Verbindungen zwischen verschiedenen Gruppen sichtbar gemacht werden.
\end{itemize}
In dieser Arbeit betrachten wir das spezielle Szenario der simultanen Pfadeinzeichnung zweier Graphen mit gleicher Knotenmenge, die auf einem orthogonalen Gitter dargestellt werden. Dabei bestehen alle Kanten ausschließlich aus horizontalen und vertikalen Liniensgementen - eine Darstellungsweise, die besonders in technischen Anwendungen wie Schaltungslayouts bevorzugt wird \cite{Takao}. Der resultierende Graph wird als Multigraph interpretiert, d.h. zwischen zwei Knoten können mehrere Kanten existieren. Ziel ist es, eine kompakte Darstellung zu erzeugen, die möglichst wenig Fläche benötigt und dennoch die strukturellen Unterschiede zwischen den Pfaden klar erkennen lässt. Es sei an dieser Stelle darauf hingewiesen, dass in dieser Arbeit Überschneidungen der Pfade erlaubt sind, jedoch dürfen sich die Pfade nicht selbst schneiden.
Ein anschauliches Beispiel für eine orthogonale simultane Einbettung zweier Pfade auf demselben Gitter zeigt \Cref{fig:simultaneous}. Der hier gezeichnete Multigraph besteht aus denselben Knoten, auf denen zwei unterschiedliche Pfade so eingebettet sind, sodass der benötigte Platz minimiert wird und dennoch die Pfadstrukturen gut unterscheidbar bleiben.
\begin{figure}[H]
    \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/Simultaneous.png}
    \caption{Simultane orthogonale Einbettung zweier Pfade auf einem Gitter}
    \label{fig:simultaneous}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
    \small
        In der Abbildung sind die Gitterkanten farblich markiert: \textcolor{blue}{blau}, wenn sie ausschließlich vom ersten Pfad verwendet werden, \textcolor{red}{rot}, wenn sie ausschließlich vom zweiten Pfad verwendet werden, und \textcolor{OliveGreen}{grün}, wenn beide Pfade denselben Abschnitt nutzen. \\
        Der erste Pfad verläuft von Knoten 2 zu Knoten 8, während der zweite Pfad bei Knoten 4 beginnt und bei Knoten 2 endet.
    \end{minipage}
\end{figure}

Durch die simultane Pfadeinzeichnung können überlappende Strukturen direkt verglichen und Konflikte – etwa Kantenkreuzungen oder unübersichtliche Umlenkungen – reduziert werden. Gleichzeitig verbessert die Orthogonalität der Darstellung die Lesbarkeit und erleichtert die Minimierung der Gesamtlänge der Pfade. Mit dem zunehmenden Bedarf an performanten Visualisierungstechniken in Industrie und Forschung gewinnt die Entwicklung effizienter Algorithmen und Modelle für die simultane Pfadeinbettung auf Gittern daher stetig an Bedeutung \cite{Handbook}.

\section{Aufbau und Zielsetzung der Arbeit}
Diese Arbeit beschäftigt sich mit der Lösung des Simultaneous Embedding-Problems durch den Einsatz von linearen Optimierungsmethoden. Ziel ist es, eine modellgestützte Herangehensweise zu entwickeln, die es ermöglicht, zwei Pfade gleichzeitig platzsparend und konfliktfrei auf einem Gitter mit einer orthogonalen Zeichnung darzustellen. Wir verwenden ein lineares-ganzzahliges Optimierungsmodell, bei welchem das Problem mit Hilfe von Variablen, Nebenbedingungen und einer Zielfunktion definiert wird und das Ergebnis als Konfiguration dieser Variablen dargestellt wird. Aus dieser Konfiguration kann dann eine entsprechende orthogonale Zeichnung abgeleitet werden. \newline
Zu Beginn der Arbeit werden die wesentlichen Begriffe aus dem Graphzeichnen und der Optimierung erläutert, um ein gemeinsames Verständnis für das behandelte Problem zu schaffen. Es folgt die formale Formulierung des Simultaneous Embedding als lineares-ganzzahliges Optimierungsproblem. Anschließend erfolgt die technische Umsetzung des Modells in Python unter der Verwendung von Gurobi. Darauf aufbauend werden Experimente zur Laufzeitanalyse und Skalierbarkeit durchgeführt, um die Praxistauglichkeit des Ansatzes zu überprüfen. Die Arbeit schließt mit einer kritischen Reflexion der Ergebnisse und der Ableitung von Potenzialen für weiterführende Forschung ab.


\chapter{Theoretische Grundlagen}
Die theoretischen Grundlagen dieser Arbeit bilden das Fundament für das Verständnis der angewandten Methoden und Modelle im Bereich der Grapheneinbettung und der Linearen Programmierung. Zunächst werden die grundlegenden Definitionen der Graphentheorie vorgestellt, gefolgt von einer Einführung in gängige Methoden und Modelle des Graphzeichnens. Danach werden die Besonderheiten und Herausforderungen des Simultaneous Embedding-Problems erläutert. Anschließend werden die grundlegenden Konzepte und Lösungsverfahren der linearen Programmierung vorgestellt und der Stand der Forschung und verwandte Arbeiten präsentiert.

\section{Grundlagen der Graphentheorie}
Wir beginnen mit den grundlegenden Definitionen der Graphentheorie, welche die Basis für die in dieser Arbeit behandelten Probleme darstellen. Wir folgen hierbei der Notation aus dem Buch \textit{Graph Theory} von Diestel \cite{GraohTh}. Ein endlicher Graph $G = (V,E)$ besteht aus einer endlichen Menge von Knoten $V$ und einer endlichen Menge von Kanten $E \subseteq V \times V$. Ein \textit{Multigraph} ist ein spezieller Graph, bei dem zusätzlich ein Mapping $M$ existiert mit $M: E \rightarrow V \cup [V]^2$, das jeder Kante ein oder zwei Endknoten zuordnet. Diese Graphen können dadurch die gleiche Kante mehrmals enthalten. Wir sagen, dass eine Kante $e = (u,v)$ \textit{inzident} ist zu $u$ und $v$. Die zwei Knoten betitelt man auch als die \textit{Endknoten} von $e$ und als \textit{adjazent} zueinander. Der \textit{Grad eines Knoten} ist die Anzahl an Kanten, die zum Knoten inzident sind. \newline
Ein \textit{Pfad} von $G$ ist ein nicht-leerer Graph $P = (V_1,E_1)$ mit  $V_1 = \{x_0,x_1,\dots, x_k\} \subseteq V$ und $E_1 = \{x_0x_1,x_1x_2,\dots,x_{k-1}x_k\} \subseteq E$, bei dem alle Knoten disjunkt sind. Einen Pfad, der alle Knoten von $G$ enthält, bezeichnet man als \textit{Hamiltonpfad}.\newline
Ein Graph ist \textit{planar}, wenn er so in eine Ebene gezeichnet werden kann, dass seine Kanten sich nur an ihren Endknoten treffen. Eine solche Zeichnung nennt man eine \textit{planare Einbettung}. \newline
Grundlegend sind Graphen abstrakte mathematische Objekte.
Konkret sind Graphen dafür geeignet, Relationen zwischen Objekten zu beschreiben. Dabei entsprechen die Objekte Knoten und die Relationen zwischen den Objekten entsprechen Kanten. Stehen eine Menge von Objekten in verschiedenen Arten in Relation, dann resultiert das in parallele Kanten, wodurch es sich um Multigraphen handelt. Durch diese Eigenschaft besitzen Graphen nicht nur in der Theorie Relevanz in Bereichen wie der Automatentheorie, formalen Sprachen und Grammatiken, sondern haben auch etliche Anwendungen im realen Leben. Seien es Straßenpläne, Produktempfehlungen bei zum Beispiel Amazon oder auch das World Wide Web, Graphen sind wichtige Bestandteile des alltäglichen Lebens\cite{DrawingMeth}.

\subsection{Graphzeichnen: Methoden und Modelle}

Das Graphzeichnen befasst sich mit der visuellen Darstellung von Graphen im zweidimensionalen oder dreidimensionalen Raum. Das zentrale Problem des Graphzeichnens lautet: Wie soll ein Graph gezeichnet werden, sodass die Informationen bestmöglich dargestellt werden? Wie schon festgestellt wurde, haben Graphen viele unterschiedliche Anwendungsbereiche. Aus diesen resultieren auch viele verschiedene Anforderungen an die visuelle Darstellung dieser Graphen.\newline
Es gibt zumindest einige allgemeine Konzepte und Techniken, die eine große Anzahl an Anwendungsbereichen abdecken. Ein gutes Layout zu erstellen, ist somit oft damit verbunden, ein oder mehrere dieser Kriterien zu optimieren. Im Buch \textit{Drawing Graphs: Methods and Models} \cite{DrawingMeth} werden einige ästhetische Kriterien benannt. Es werden nun die Kriterien aufgezählt, die im Kontext der simultanen Einbettung wichtig sind: 
\begin{itemize}
    \item  \textbf{Kreuzungsminimierung:} Wenn zu viele Kreuzungen von Kanten existieren, dann fällt es dem menschlichen Auge schwerer zu sehen, welche Knoten durch die Kanten verbunden sind. Ist eine Zeichnung ohne Kreuzung möglich, dann sind diese oft zu bevorzugen. Die Minimierung von Kreuzungen ist auch ein wichtiges technisches Kriterium in Gebieten wie Schaltplänen, um die Anzahl an Schichten zu reduzieren.
    \item  \textbf{Biegungsminimierung:} Dieses Kriterium ist von Bedeutung, da das menschliche Auge Kanten mit wenigen Biegungen leichter verfolgen kann. Auch in VLSI-Schaltungen stellen Biegungen in Leitungen potenzielle Schwachstellen dar und können zu Problemen wie Signalreflexionen oder Verzögerungen führen.
    \item  \textbf{Flächenminimierung:} Das Minimieren der genutzten Fläche sorgt für ein ansprechenderes Bild durch das Füllen des Platzes mit homogener Dichte. Insbesondere in Städten ist es wichtig, die Verkehrs- und Infrastrukturelemente so zu platzieren, dass sie wenig Fläche verbrauchen, um mehr Raum für Bebauung oder Grünflächen zu lassen.
    \item  \textbf{Kantenlängenminimierung:} Die Kantenlängenminimierung verbessert die Lesbarkeit, da nahe beieinanderliegende Knoten Zusammenhänge schneller erkennbar machen. Besonders in der Verkehrsnetzplanung werden Kanten möglichst kurz gehalten, um Straßen effizient zu platzieren und die Übersichtlichkeit der Karte zu erhöhen.
\end{itemize}
Nachdem nun grundlegende ästhetische Kriterien für Graphenzeichnung erläutert wurden, soll im Folgenden auf verschiedene spezielle Zeichnungsmodelle eingegangen werden. Diese Modelle beschreiben konkrete Konventionen und Regeln, nach denen Graphen unter bestimmten geometrischen und technischen Beschränkungen visualisiert werden.\newline
Je nach Anwendungsgebiet kommen unterschiedliche Darstellungsformen zum Einsatz, um spezifische Anforderungen - wie etwa eine klare Strukturierung, Platzersparnis oder technische Umsetzbarkeit – zu erfüllen. Zu den bekanntesten und am häufigsten verwendeten Modellen zählen orthogonale Zeichnungen und Straight-Line-Zeichnungen, aber auch weitere Varianten, die je nach Problemstellung bevorzugt werden.
Im Folgenden werden zwei von diesen speziellen Zeichnungsmodellen vorgestellt\cite{Handbook}.\newline \newline
Ein \textbf{Straight-Line Drawing}  eines Graphen $G = (V,E)$ ist eine Einbettung von $G$ in die Ebene, bei der jeder Knoten $v \in V$ als eindeutiger Punkt im $\mathbb{R}^2$ dargestellt wird und jede Kante $e = (u,v) \in E$ durch ein gerades Liniensegment zwischen den Punkten $u$ und $v$ repräsentiert wird. Alle Kanten sind dabei gerade und enthalten keine Biegungen.\newline

Eine \textbf{orthogonale Zeichnung} eines Graphen $G = (V,E)$ ist eine Einbettung von $G$ in die Ebene, bei der jeder Knoten $v \in V$ als Punkt im $\mathbb{R}^2$ dargestellt wird und jede Kante $e = (u,v) \in E$ ausschließlich aus horizontalen und vertikalen Liniensegmenten besteht. Kanten können dabei rechtwinklige Biegungen enthalten.\newline


\subsection{Simultaneous Embedding}
Das Konzept des \emph{Simultaneous Embedding} beschäftigt sich mit der gleichzeitigen Darstellung mehrerer Graphen, die auf derselben Knotenmenge basieren. Die Herausforderung besteht darin, für jeden der beteiligten Graphen eine planare Einbettung zu finden, während die Knoten an identischen Positionen platziert werden. Dadurch sollen die individuellen topologischen Eigenschaften jedes Graphen erhalten bleiben, obwohl sie sich in der Gesamtdarstellung überschneiden können.\newline
In vielen Anwendungsfeldern treten Situationen auf, in denen mehrere Graphen auf der gleichen Knotenmenge definiert sind und gemeinsam visualisiert werden sollen. Das Problem wird ausführlich im \textit{Handbook of Graph Drawing and Visualization}\cite{Handbook} beschrieben. Dies ist etwa in Datenbanken, bei der Analyse sozialer Netzwerke oder im Bereich der Bioinformatik der Fall. \newline
Ein anschauliches Beispiel aus der Evolutionsbiologie ist die Darstellung sogenannter phylogenetischer Bäume, die die evolutionären Verwandtschaftsverhältnisse zwischen Arten abbilden. Abhängig von den verwendeten Annahmen und Algorithmen entstehen hier oftmals unterschiedliche Bäume. Ein direkter Vergleich dieser unterschiedlichen Ergebnisse und das Formulieren der wahrscheinlichsten evolutionären Hypothese gestaltet sich schwierig, wenn die Bäume unabhängig voneinander gezeichnet werden und die Knotenpositionen nicht übereinstimmen. \newline
Selbst wenn die zugrunde liegenden Graphen in solchen Anwendungen nicht notwendigerweise planar sind, liefert die Betrachtung des planaren Falls wertvolle Einsichten und dient häufig als Grundlage für die Entwicklung von Lösungen für allgemeinere, nicht-planare Szenarien \cite{Handbook}.\newline
Je nach konkretem Anwendungsfall und den zugrunde liegenden Einschränkungen existieren unterschiedliche Varianten des Simultaneous Embedding. Im Folgenden sollen drei zentrale Ansätze vorgestellt werden, die sich in der Literatur etabliert haben. Diese Ansätze unterscheiden sich insbesondere hinsichtlich der erlaubten Freiheiten bei der Anordnung der Knoten und der Darstellung der Kanten und sind in der \Cref{fig:SE_Example} schematisch dargestellt.
\begin{itemize}
    \item \textbf{Simultaneous Geoemtric Embedding (SGE):} Hierbei werden alle Graphen mit geradlinigen Kanten gezeichnet. Diese Variante ist sehr restriktiv und führt häufig zu Nicht-Existenz-Ergebnissen, wenn die Graphen zu unterschiedliche Strukturen aufweisen.
    \item  \textbf{Simultaneous Embedding with Fixed Edges (SEFE):} In dieser Variante dürfen Kanten Biegungen aufweisen, wobei gemeinsame Kanten in den beteiligten Graphen exakt übereinstimmen. Dies erlaubt in vielen Fällen flexiblere Lösungen, da lokale Anpassungen an den Kantenverläufen möglich sind.
    \item \textbf{Simultaneous Embedding:} Hier gibt es keine Einschränkungen für die Darstellung von Kanten. Es wird nur gefordert, dass gemeinsame Knoten gleiche Positionen haben.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics{figures/Handbook1.png}
    \caption{Zwei Graphen $G_1$ und $G_2$ zusammen mit einer SGE, einer SEFE und einer SE. In der SGE sind alle Kanten als Geraden dargestellt, während in der SEFE einige Kanten nicht geradlinig verlaufen. Die SE enthält gemeinsame Kanten $(\{3,7\})$ und  $(\{5,6\})$, die in $G_1$ und $G_2$ unterschiedlich gezeichnet sind \protect\footnotemark}
    \label{fig:SE_Example}
\end{figure}
\footnotetext{Tamassia, R. (Hrsg.), \textit{Handbook of Graph Drawing and Visualization}, Kapitel 11, CRC Press, 2014.}


Die Forschung hat gezeigt, dass für bestimmte Klassen von Graphen (beispielsweise für Bäume, Pfade oder sogar für einige sogenannte 3-fach zusammenhängende planare Graphen) effiziente Algorithmen existieren, die eine simultane Einbettung ermöglichen. Dabei spielen Parameter wie die Gittergröße, die maximale Anzahl der Biegungen pro Kante sowie ästhetische Kriterien (z.,B. Minimierung von Überschneidungen und Maximierung der Lesbarkeit) eine zentrale Rolle.\newline
De Fraysseix et al. \cite{DeFraysseix1990} haben gezeigt, dass es einen Algorithmus in $\mathcal{O}(n \log n)$ gibt, wobei $n$ die Anzahl an Knoten ist, der jeden planaren Graph in ein Straight-Line-Drawing einbetten kann auf einem $(2n-4\times n-2)$-Gitter. Ergänzend dazu trug die Arbeit von Chrobak und Payne \cite{CHROBAK1995241} dazu bei, einen entsprechenden linearen Algorithmus für diese Gitterzeichnung zu entwickeln.\newline
Brass et al. \cite{BRASS2007117}  untersuchen die Bedingungen, unter denen simultane planare Einbettungen möglich sind und differenzieren explizit zwischen Fällen mit und ohne vorgegebene Knotenabbildung (Mappings). Ihre Ergebnisse verdeutlichen, dass das vorliegen eines festen Mappings das Problem erheblich erschwert (siehe Tabelle~\ref{tab:graph-mapping}).\newline
\begin{table}[H]
\centering
\begin{tabular}{llcc}
\toprule
\textbf{} & \textbf{Graphs} & \textbf{With mapping} & \textbf{Without mapping} \\
\midrule
& $G_1$: Planar, $G_2$: Outerplanar & not always possible & $O(n^2) \times O(n^2)$ \\
& $G_1$: Planar, $P_2$: Path & not always possible & $O(n^2) \times O(n^2)$ \\
& $G_1, G_2, \dots, G_k$: Outerplanar & not always possible & $O(n) \times O(kn)$ \\
& $C_1, C_2$: Caterpillar & $3n \times 3n$ & $O(n) \times O(n)$ (outerplanar) \\
& $C_1$: Caterpillar, $P_2$: Path & $n \times 2n$ & $O(n) \times O(n)$ (outerplanar) \\
& $S_1, S_2, \dots, S_k$: Star & $O(c^k \sqrt{n}) \times O(c^k \sqrt{n})$ & $O(\sqrt{n}) \times O(\sqrt{n})$ \\
& $X_1$: Extended star, $P_2$: Path & $O(n^2) \times O(n)$ & $O(n) \times O(n)$ (outerplanar) \\
& $P_1, P_2$: Path & $n \times n$ & $\sqrt{n} \times \sqrt{n}$ \\
& $C_1, C_2$: Cycle & $4n \times 4n$ & $\sqrt{n} \times \sqrt{n}$ \\
& $P_1, P_2, P_3$: Path & not always possible & $\sqrt{n} \times \sqrt{n}$ \\
\bottomrule
\end{tabular}
\caption{Vergleich der Gittergrößen mit und ohne Mapping für verschiedene Graphenkombinationen\protect\footnotemark}
\label{tab:graph-mapping}
\end{table}
\footnotetext{Brass, P., Dobbins, M., Kobourov, S.G., \textit{On simultaneous planar graph embeddings}, Computational Geometry, 36(2), 2007, S. 117–130.}

Zur Komplexität des Problems wurde von Estrella-Balderrama et al.\cite{Estrella} festgestellt, dass das simultane Einbetten von nur zwei Graphen, so dass das Straight-Line-Drawing jedes einzelnen planar ist, NP-hart ist. Auch SEFE ist NP-hart für drei planare Graphen, während die Komplexität bei zwei planaren Graphen noch unklar ist \cite{Gassner}. 

\section{Einführung in linearer Programmierung}
Die lineare Programmierung (LP) bildet einen zentralen Baustein der Optimierung und ist in vielen Disziplinen von grundlegender Bedeutung. Dabei geht es darum, eine lineare Zielfunktion unter Berücksichtigung linearer Nebenbedingungen zu optimieren – sei es durch Maximierung eines Gewinns, Minimierung von Kosten oder Optimierung anderer wirtschaftlicher und technischer Kennzahlen.\newline
LP-Modelle finden breite Anwendung, von der Produktionsplanung über Transportprobleme bis hin zu komplexen Netzwerkflussproblemen. In diesem Kapitel werden die grundlegenden Definitionen und Prinzipien der LP erläutert sowie die gängigen Lösungsverfahren vorgestellt.
Die nachfolgenden Definitionen basieren auf den allgemeinen Konzepten, wie es von Domschke und Drexl \cite{Operation} beschreiben wird.

\subsection{Definitionen und Prinzipien der LP}
Ein klassisches LP- Problem wird folgendermaßen formuliert
\begin{definition}
    Unter einem \textbf{linearen Optimierungs-} oder \textbf{Programmierungsproblem (LP)} versteht man die Aufgabe, eine \textit{lineare (Ziel-) Funktion} $F(x_1,\dots, x_p) = c_1x_1 + \dots + c_px_p$ zu maximieren (oder zu minimieren) unter Beachtung von linearen Nebenbedingungen der Form
    \begin{align}
    a_{i1}x_1 + \dots + a_{ip}x_p &\leq b_i \quad \text{für } i = 1,\dots, m_1 \\
    a_{i1}x_1 + \dots + a_{ip}x_p &\geq b_i \quad \text{für } i = m_1+1,\dots, m_2 \\
    a_{i1}x_1 + \dots + a_{ip}x_p &= b_i \quad \text{für } i = m_2+1,\dots, m \\
    \intertext{und zumeist unter Berücksichtigung der Nichtnegativitätsbedingungen}
    x_j &\geq 0 \quad \text{für (einige oder alle) } j = 1,\dots,p
\end{align}
\end{definition}
 Im Kontext der linearen Programmierung ist es von großer Bedeutung, Lösungen zu identifizieren, die die gegebenen Nebenbedingungen erfüllen. Eine Lösung des LP-Problems muss daher nicht nur die Zielfunktion optimieren, sondern auch alle linearen Restriktionen einhalten. Die Zulässigkeit der Lösung ist dabei ein zentrales Kriterium. 
\begin{definition}
    \leavevmode\
    \begin{enumerate}[a)]
        \item Einen Punkt (oder Vektor) $\textbf{x} = (x_1,\dots,x_p)$ des $\mathbb{R}^p$, der alle Nebenbedingungen (2.1)-(2.3) erfüllt, nennt man \textbf{Lösung} des LP.
        \item Erfüllt \textbf{x} außerdem (2.4), so heißt \textbf{x zulässige Lösung}.
        \item Eine zulässige Lösung $\textbf{x*} = (x^*_1, \dots, x^*_p)$ heißt \textbf{optimale Lösung} des LP, wenn es kein zulässiges \textbf{x} mit größerem bzw. mit kleinerem Zielfunktionswert als $F($\textbf{$x^*$}$)$ gibt.
        \item Mit X bezeichnen wir die Menge der zulässigen Lösungen, mit $X^*$ die Menge der optimalen Lösungen eines LP
    \end{enumerate}
\end{definition}
Neben der klassischen linearen Programmierung gibt es auch die \textbf{ganzzahlige lineare Programmierung(ILP)}, die ein spezielles Unterfeld darstellt. Bei einem ILP-Problem handelt es sich um ein lineares Optimierungsproblem, bei dem einige oder alle Variablen ganzzahlige Werte annehmen müssen. Dies führt zu einer wesentlich höheren Komplexität, sowohl in theoretischer als auch in praktischer Hinsicht.\newline
In der Komplexitätstheorie bezeichnet \textbf{P}  die Klasse von Entscheidungsproblemen, die sich mit einem deterministischen Algorithmus in polynomieller Zeit lösen lassen. Die Klasse \textbf{NP} (nichtdeterministisch polynomiell) umfasst Probleme, bei denen eine gefundene Lösung in polynomieller Zeit überprüft werden kann – selbst wenn die Berechnung dieser Lösung selbst möglicherweise exponentiellen Aufwand erfordert.\newline
LPs, bei denen alle Variablen reelle Werte annehmen können, gehören zur Komplexitätsklasse P und sind damit nicht NP-hart. Dies bedeutet, dass LPs in polynomieller Zeit gelöst werden können. Zwei bekannte und oft eingesetzte Methoden zur Lösung von LPs sind das \emph{Simplex-Verfahren} und die \emph{Interior-Point-Methoden} \cite{LinearProg}.  Das Simplex-Verfahren, obwohl in der Praxis sehr effizient, hat keine garantierte polynomiale Laufzeit. Es kann im schlimmsten Fall exponentielle Zeit benötigen, um die optimale Lösung zu finden, auch wenn es für viele reale Probleme erstaunlich schnell konvergiert. Innere-Point-Methoden hingegen bieten eine polynomiale Laufzeitgarantie und stellen sicher, dass eine optimale Lösung in polynomieller Zeit gefunden wird. Diese Methoden haben das Problem der exponentiellen Laufzeit beim Simplex-Verfahren effektiv gelöst und sind insbesondere für größere Probleme von Bedeutung.\newline
Im Gegensatz zu LPs, die effizient gelöst werden können, gehören ILPs zur NP-harten Klasse. Dies bedeutet, dass ILPs nicht in polynomieller Zeit gelöst werden können, es sei denn, P=NP. Die Entscheidung, ob eine optimale Lösung existiert, oder die Suche nach der optimalen Lösung ist für ILPs wesentlich schwieriger als bei LPs, weil die Variablen nur ganze Zahlen annehmen dürfen. Diese zusätzliche Einschränkung führt dazu, dass der Lösungsraum nicht mehr konvex ist. Ein konvexes Optimierungsproblem zeichnet sich dadurch aus, dass die Zielfunktion und der zulässige Bereich eine einfache Struktur haben, die es ermöglicht, das globale Optimum effizient zu finden. Bei konvexen Problemen garantiert die Struktur, dass es keine lokalen Minima gibt, die das Finden der besten Lösung erschweren. Daher können konvexe Probleme mit polynomiellen Algorithmen wie dem Simplex-Verfahren oder Interior-Point-Verfahren effizient gelöst werden. Ein ILP-Problem zu lösen, bedeutet, über alle möglichen ganzzahligen Lösungen nachzudenken, was zu einer enormen Zunahme der Komplexität führt.\newline
Ein klassisches Beispiel für ein ILP ist das \textbf{Travelling Salesman Problem (TSP)}. Bei diesem Problem geht es darum, einen kürzesten Rundweg zu finden, der alle Städte in einer gegebenen Liste genau einmal besucht und zum Ausgangspunkt zurückkehrt. Dieses NP-harte Problem kann als ILP formuliert werden, bei dem jede Entscheidung, ob eine bestimmte Stadt direkt vor einer anderen besucht wird, als binäre Variable dargestellt wird.\newline
Ein weiteres Beispiel ist das \textbf{quadratische Zuordnungsproblem (QAP)}. Bei diesem Problem geht es darum, $n$ gleichgroße Maschinen in $n$ gleichgroße Plätze so zu platzieren, dass die Gesamtkosten für den Materialtransport zwischen den Maschinen minimiert wird. Die Kosten hängen dabei von der Entfernung zwischen den Maschinen und der Häufigkeit ab, mit der Materialien transportiert werden müssen. Das QAP kann als ILP formuliert werden, bei dem jede Entscheidung, welche Maschine an welchen Standorten platziert werden, durch binäre Variablen dargestellt wird.

\subsection{Lösungsverfahren für ILP}
Ein zentrales Verfahren zur Lösung von ganzzahligen linearen Programmen (ILPs) ist der \emph{Branch-and-Bound-Algorithmus} (B\&B). Dabei wird das ursprüngliche Optimierungsproblem in kleinere Teilprobleme (sogenannte Knoten) unterteilt. In jedem Knoten wird zunächst eine Relaxation des ILPs betrachtet, bei der die Ganzzahligkeitsbedingung vorübergehend aufgehoben wird, sodass ein reines LP gelöst werden kann. Diese Relaxation dient dazu, eine untere Schranke für das jeweilige Teilproblem zu berechnen. Ergibt sich dabei eine nicht-ganzzahlige Lösung, wird das Problem in zwei neue Teilprobleme verzweigt (Branching), wobei in jedem Teilproblem zusätzliche Nebenbedingungen eingeführt werden, die die Variablen weiter einschränken. Die Methode nutzt dabei auch Bounding, indem ganze Teilprobleme ausgeschlossen werden, wenn feststeht, dass sie keine bessere Lösung als eine bereits gefundene liefern können.\newline
Zur weiteren Reduktion des Suchraums kommen \emph{Cutting-Plane-Verfahren} zum Einsatz. Diese Methode ergänzt das Problem um zusätzliche Ungleichungen (Schnitte), die nicht-ganzzahlige Lösungen aus der Relaxation ausschließen, ohne dabei zulässige ganzzahlige Lösungen zu entfernen. Zu den klassischen Schnitten zählen die Gomory Cuts, die auf Basis der Simplex-Tabelle generiert werden, um nicht-ganzzahlige Eckpunkte des Relaxationspolytops auszuschließen. Weitere verbreitete Schnitte sind Cover Cuts, die speziell für Ungleichungen vom Knapsack-Typ entwickelt wurden, und Zero-half Cuts, die eine spezielle Struktur ausnutzen, um den Lösungsraum enger zu fassen. Besonders leistungsfähig sind auch RLT Cuts (Reformulation-Linearization Technique), welche die Struktur quadratischer oder nichtlinearer ILPs in lineare Form bringen und dabei starke Schnitte erzeugen.\newline
Ein kombiniertes Verfahren ist das sogenannte \emph{Branch-and-Cut}, bei dem Schnitte bereits während der Knotenverarbeitung (vor oder während des Branchings) eingesetzt werden. Dadurch lassen sich die Relaxationen verschärfen und die Zahl der Knoten im Branch-and-Bound-Baum deutlich reduzieren. Diese Strategie hat sich in der Praxis als sehr effektiv zur Lösung großer und komplexer ILPs erwiesen.\newline
Zusätzlich nutzen moderne Ansätze häufig ein Presolve-Verfahren, das vor der eigentlichen Optimierung angewendet wird. Dabei werden überflüssige Variablen und Nebenbedingungen entfernt, Dominanzbeziehungen erkannt und das Modell insgesamt vereinfacht.\newline
In der Praxis kombinieren leistungsfähige Solver wie beispielsweise Gurobi\cite{Gurobi2025} diese Methoden zu leistungsstarken hybriden Verfahren, die Branch-and-Bound, Cutting-Planes und Presolve-Techniken gemeinsam einsetzen, um ILPs effizient zu lösen.


\section{Stand der Forschung und verwandte Arbeiten}
Im Fokus der Untersuchungen zu orthogonalen Zeichnungen steht insbesondere die Minimierung der benötigten Gitterfläche und die Minimierung der benötigten Biegungen. Formann und Wagner \cite{NP-orth} zeigen, dass das Finden einer  Zeichnung für zusammenhängende, planare Graphen NP-hart ist. Diese Erkenntnis unterstreicht die algorithmische Komplexität, die bereits bei der Flächenoptimierung – und damit indirekt auch beim Minimieren von Biegungen – besteht.\newline
Biedl \cite{Biedl} erweitert diesen Blickwinkel, indem in ihren Untersuchungen neue untere Schranken für die benötigte Gittergröße sowie für die minimale Anzahl an Biegungen in orthogonalen Zeichnungen hergeleitet werden. Die präsentierte Tabelle~\ref{tab:bie96table} fasst dabei quantitativ die erzielten Grenzen zusammen und liefert wichtige Vergleichswerte für unterschiedliche Graphklassen.
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{llcccc}
\toprule
\textbf{Plane Drawings} & & \textbf{Triconnected} & \textbf{Biconnected} & \textbf{Connected} & \textbf{Non-Connected} \\
\midrule
\multirow{2}{*}{Simple} 
 & Grid-size & $\frac{2}{3}n + 1$ & $n - 1$ & $\frac{6}{5}(n - 1) - 1$ & ? \\
 & Bends     & $\frac{4}{3}n + 4$ & $2n - 2$\,* & $\frac{12}{5}(n - 1) - 2$ & ? \\
\midrule
\multirow{2}{*}{Multigraph} 
 & Grid-size & $\frac{2}{3}(n - 2) + 3$ & $n + 1$ & $2n - 3$ & $2n - 1$ \\
 & Bends     & $\frac{4}{3}(n - 2) + 8$ & $2n + 4$\,* & $4n - 6$ & $4n$ \\
\midrule
\multirow{2}{*}{With Loops} 
 & Grid-size & -- & $n + 2$ & $2n + 1$ & $4n - 1$ \\
 & Bends     & -- & $3n$ & $4n + 4$ & $6n$ \\
\bottomrule
\end{tabular}
}
\caption{Untere Schranken für orthogonale Darstellungen. Ein '–' zeigt an, dass dieser Fall unmöglich ist, während ein '?' darauf hinweist, dass keine besseren unteren Schranken als im Fall zusammenhängender Graphen gefunden wurden\protect\footnotemark}
\label{tab:bie96table}
\end{table}
\footnotetext{Biedl, T., \textit{New lower bounds for orthogonal graph drawings}, Graph Drawing, 1995, S. 28-39.}
Dabei zeigt sich eine enge Verbindung zwischen der Gittergröße und der Anzahl der Biegungen. Konkret gilt: Ist eine obere Schranke für die Anzahl an Biegungen bekannt, so ergibt sich daraus auch eine obere Schranke für die benötigte Gittergröße. Umgekehrt kann eine untere Schranke für die Gittergröße eine untere Schranke für die Anzahl der Biegungen implizieren \cite{BendsSize}.\newline 
Papakostas und Tollis \cite{Pairing} stellen in ihrem Ansatz eine Paarungstechnik von Knoten des Graphen vor, die einen linearen Algorithmus liefert. Sei $n$ im Folgenden die Anzahl an Knoten im Graphen. Dieser Algorithmus erreicht für Graphen mit einem maximalen Knotengrad von 4 eine Fläche von etwa $0,76n^2$, während gleichzeitig die Anzahl der Biegungen  auf höchstens $2n+2$ minimiert wird. Für Graphen mit einem höheren Knotengrad als 4 bieten die Ergebnisse von Papakostas und Tollis \cite{Papakostas2000} signifikante Verbesserungen. Ihre Ansätze erweitern die klassischen Modelle, sodass auch komplexere Graphstrukturen effizient orthogonal gezeichnet werden können, ohne dass der Flächenverbrauch oder die Anzahl der Biegungen unverhältnismäßig ansteigt. Ihre Ergebnisse liefern einen linearen Algorithmus für orthogonale Zeichnungen mit höchstens $(m-1)\times (m/2 + 2)$ benutzter Fläche, wobei $m$ die Anzahl an Kanten ist.\newline
Ein weiterer bedeutender Ansatz zur Optimierung orthogonaler Zeichnungen basiert auf der Anwendung von ILP. Mutzel und Weiskircher präsentieren ein ILP-Modell zur Bend-Minimierung, das eine Netzwerkfluss-Formulierung nutzt, um orthogonale Zeichnungen für 2-fach zusammenhängende Graphen mit einer minimalen Anzahl an Biegungen zu erzeugen \cite{ILPBEND}.\newline
Die Ergebnisse zeigen, dass ILP ein leistungsfähiges Werkzeug zur Optimierung orthogonaler Zeichnung ist. Ein vielversprechender weiterführender Ansatz ist die Anwendung von ILP nicht nur für die Optimierung einzelner orthogonaler Zeichnungen, sondern auch für die gleichzeitige Einbettung mehrerer Graphen. Insbesondere bei der simultanen Pfadzeichnung könnte ILP genutzt werden, um sowohl Biegungen als auch Flächenverbrauch simultan für mehrere Graphen zu minimieren, während strukturelle und topologische Einschränkungen gewahrt bleiben.


\chapter{Methodik und Modellierung}
\section{Formulierung des Problems als ILP}
Es sei $G = (V,E)$ der Multigraph der in ein Gitter $D=(P,F)$ eingebettet werden soll, wobei $V=\{v_1,v_2,\dots, v_n\} $ die Knoten und $E=\{e_1, e_2, \dots, e_n\}$ die entsprechenden Kanten darstellt. Das Gitter ist hierbei ein Tupel aus Gitterpunkten $P=\{(x,y) \mid (x,y) \in \mathbb{Z^2} \}$ und Gitterkanten $F=\{(p,q) \mid p,q \in P\}$. Die Kanten kann man nun in zwei Mengen partitionieren, denen man dann zwei verschiedenen Hamiltonpfaden zuordnet. Ziel ist es nun, diese zwei Pfade so auf einem Gitter zu zeichnen, sodass diese für sich gesehen planar auf diesem Gitter eingebettet sind. Dabei soll dies möglichst optimiert bezüglich des genutzten Platzes auf einem Gitter $D=(P,F)$ vollzogen werden. Es ist also erlaubt, dass sich die Pfade gegenseitig kreuzen können. \Cref{fig:Grid_Example} veranschaulicht erlaubte Zeichnungen von zwei Pfaden auf dem Gitter. \newline
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Erlaubt.pdf}
        \caption{Erlaubte Zeichnung}
        \label{fig:erlaubt}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Unerlaubt.pdf}
        \caption{Verbotene Zeichnung}
        \label{fig:unerlaubt}
    \end{subfigure}
    \hfill
    \caption{Erlaubte und verbotene Zeichnungen}
    \label{fig:Grid_Example}
\end{figure}
Um für diese Aufgabenstellung ein entsprechendes ganzzahliges lineares Optimierungsproblem zu formulieren, werden zuerst Variablen definiert, sodass danach eine Zielfunktion und Nebenbedingungen geschaffen werden können. \newline
Jeden Knoten $v \in V$ muss einem Gitterpunkt $p \in D$ zugeordnet werden, auf welchem der Knoten platziert wird. Hierfür definieren wir für alle Knoten $v \in V$ und jeden Gitterpunkt $p \in D$ die Variable $\sigma(v,p)$. Gilt nun, dass der Knoten $v$ auf dem Gitterpunkt $p$ liegt, dann gilt $\sigma(v,p) = 1$, ansonsten gilt $\sigma(v,p) = 0$.  \newline
Für jede Kante $e \in E$ und jede Gitterkante $(p,q) \in F$ benötigen wir zudem noch eine Variable $\mu(e,p,q)$, die analog zu $\sigma(v,p)$ den Wert 1 annimmt, wenn die Kante $e$ die Gitterkante $(p,q)$ belegt, ansonsten den Wert 0.\newline
\begin{figure}[H]
    \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics{figures/Variabelsetzung.pdf}
    \caption{Visualisierung einer Belegung in einem Gittergraphen}
    \label{fig:Var_Example}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
    \small
    \Cref{fig:Var_Example} illustriert eine exemplarische Belegung der Variabeln in einem Gittermodell. Die Knoten $v_1$ und $v_2$ sind den Positionen $(1,1)$ und $(2,1)$ zugeordnet, sodass $$\sigma(v_1,(1,1))=\sigma(v_2,(2,1))=1$$ und $$\mu((v_1,v_2),(1,1),(2,1))=1 \text{ gilt.}$$ Alle übrigen Variablen sind auf $0$ gesetzt.
    \end{minipage}
\end{figure}
Wir möchten nun die Anzahl an gebrauchten Gitterkanten minimieren. Da dadurch auch adjazente Knoten nahe aneinander gelegt werden müssen, wird der benutzte Platz auf dem Gitter verkleinert. Hierfür ist folgende Zielfuntkion $F(x) = z$  zu minimieren mit $$z = \sum_{e \in E} \sum_{(p,q) \in F} \mu(e,p,q)$$
Damit die Pfade korrekt eingebettet werden können, sind einige Nebenbedingungen notwendig:
\begin{enumerate}[(1)]
    \item  Jeder Knoten muss auf genau einem Gitterpunkt liegen
    \item Auf einem Gitterpunkt darf höchstens ein Knoten liegen
    \item Kanten müssen kontinuierlich gezeichnet werden
    \item Kanten dürfen keine Gitterpunkte durchlaufen, an dem ein Knoten liegt, der nicht zu der jeweiligen Kante inzident ist
    \item Es darf keine Überschneidungen innerhalb eines Pfades geben
\end{enumerate}
Jeder Knoten $v \in V$muss auf genau einem Gitterpunkt $p \in P$ liegen, wobei kein Gitterpunkt von mehreren Knoten belegt werden darf. Damit dies gesichert ist, sind zwei Nebenbedingungen notwendig. Für Ersteres muss folgende Bedingung gelten: 
     \begin{equation}
\forall v \in V \sum_{p \in P} \sigma(v,p) = 1
\tag{1}
\end{equation}
Damit gilt, dass jeder Gitterpunkt von höchstens einem Knoten belegt wird, muss gelten:

\begin{equation}
    \forall p \in P \sum_{v \in V} \sigma(v,p) \leq 1
    \tag{2}
\end{equation}
Nun müssen wir sicherstellen, dass auch die Kanten der Pfade korrekt eingebettet werden. Kanten dürfen nicht abrupt stoppen und an einer komplett anderen Stelle weiterlaufen. Zudem dürfen sie nicht über platzierte Knoten laufen. Auch ist es wichtig, dass der Pfad sich nicht selbst kreuzen darf. Um all dies zu verhindern, sind einige Nebenbedingungen notwendig. \newline
Damit Kanten kontinuierlich sind beobachten wir, wie sich eine Kante $e \in E$ mit $e = (u,v)$ verhält. Seien nun $\sigma(u,p) = 1 \land \sigma(v,q) = 1$ für beliebige $p,q \in D, p \neq q$. Man sieht, dass die Kante $e$ den Gitterpunkt $p$ genau einmal ausgehend verlässt und eine Gitterkante zu einem anderen Gitterpunkt dafür benutzt.  Da Pfade kreisfrei sind, gibt es keine eingehende benutzte Gitterkante und nicht noch mehr ausgehend benutzte Gitterkanten beim Startknoten. Analog gilt dies für den Endknoten $v$ dieser Kante. Für alle anderen Gitterpunkte $r \in D, r \neq p,q$ gilt nun, dass die Kante $e$ diese möglicherweise passiert. In diesem Fall benutzt $e$ eine eingehende Gitterkante und eine entsprechende ausgehende Gitterkante. Passiert $e$ einen Gitterpunkt nicht, dann gibt es weder eingehende noch ausgehende benutzte Gitterkanten an dem Punkt. In jedem Fall kann man schließen, dass die Summe an eingehenden Gitterkanten und ausgehenden Gitterkanten an einem Gitterpunkt, die die Kante $e$ benutzt, identisch sein müssen außer an den Positionen der Endknoten $u,v$, bei der die Differenz gleich 1 ist, damit es keine abrupten Kantenabbrüche existieren und zudem gesichert ist, dass die Kante bei $u$ anfängt und $v$ endet. Als Nebenbedingung ergibt sich: 
\begin{equation}
    \forall e=(u,v) \in E, u,v \in V, \forall p \in D: \sum_{(p,q) \in F} \mu(e,p,q) - \sum_{(q,p) \in F} \mu(e,q,p) = \sigma(u,p) - \sigma(v,p)
    \tag{3}
\end{equation}

In \Cref{fig:Kontinuierlich} wird die Gültigkeit dieser Nebenbedingung verdeutlicht.
\begin{figure}[H]
    \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics{figures/Kontinuierlich.pdf}
    \caption{Beispiel für eine kontinuierliche Kante $e=(u,v)$ und eine ungültige Kante $e'=(u',v')$}
    \label{fig:Kontinuierlich}
    \end{minipage}
    \begin{minipage}{0.47\textwidth}
    \small
    Die Bedingung summiert die eingehenden und ausgehenden Gitterkanten an einem Punkt auf und bildet die Differenz von diesen. Abhängig davon, ob an dem Punkt ein inzidenter Knoten liegt, muss die Differenz einer der drei Werte annehmen $\{-1,0,1\}$.\newline
    In der Abbildung gilt die Bedingung korrekt für den Startpunkt $p$ (eine ausgehende Gitterkante) mit $\sigma(u,p) = 1$, analog gilt sie auch für den Endpunkt $q$. Auch am Gitterpunkt $r$ gilt sie, wobei die linke als auch die rechte Seite der Gleichung den Wert 0 annimmt. Am Punkt $r'$ hingegen ist diese nicht erfüllt, da es eine eingehende Kante gibt, jedoch ist $\sigma(u,r') - \sigma(v,r') = 0$.

    \end{minipage}
\end{figure}
Uns fehlt nun noch, dass eine Kante keinen Gitterpunkt passieren darf, an dem schon ein Knoten gelegt wurde, der nicht zu der Kante inzident ist. Definieren wir dafür die Summe aller eingehenden und ausgehenden genutzten Gitterkanten am Gitterpunkt $p$ von einer Kante $e$: $$flow\_sum = \sum_{(p,q) \in F} \mu(e,p,q) + \sum_{(q,p) \in F} \mu(e,q,p)$$
Für jede Kante $e$ an jedem Gitterpunkt $p$, an dem ein nicht inzidenter Knoten $w$ liegt, muss gelten, dass $e$ diese Stelle nicht passieren darf. Liegt an der Stelle kein Knoten, dann darf die Kante $e$ diesen Punkt passieren :
\begin{equation}
flow\_sum \leq 2 \cdot (1 - \sigma(w,p))
\tag{4}
\end{equation}
\begin{figure}[H]
    \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics{figures/OverNodePoint.pdf}
    \caption{Beispiel für eine Kante $e=(u,v)$, die über einen Knoten $w$ verläuft}
    \label{fig:OverNodePoint}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
    \small
    In \Cref{fig:OverNodePoint} verletzt $w$ diese Bedingung, da die Kante durch ihn verläuft. 
    Die Bedingung liefert hierbei:$$flow\_sum=2 \leq 0 = 2 \cdot (1-\sigma(w,p))$$ Bei $w'$ hingegen wird der Knoten korrekt platziert, wodurch die Bedingung erfüllt.
    \end{minipage}
\end{figure}
Abschließend fehlt uns nur noch eine Nebenbedingung, die verhindert, dass es innerhalb eines Pfades zu Überschneidungen kommt. Sei nun $W$ die Menge an Pfaden. Für alle $P_i =(V_i, E_i) \in W$  mit $V_i\subseteq V$ und  $E_i \subseteq E$ und für jeden Gitterpunkt $p \in D$ definieren wir die aggregierte Anzahl an korrespondierenden Gitterkanten an $p$, die von den Kanten $e_i \in E_i$ genutzt werden: $$aggregated\_flow = \sum_{e \in p_i}(\sum_{(p,q) \in F} \mu(e,p,q) + \sum_{(q,p) \in F} \mu(e,q,p))$$  Nun gibt es zwei Szenarien für jeden Pfad. Entweder wird der Gitterpunkt $p$ gar nicht passiert, wodurch gilt $aggregated\_flow = 0$ oder der Punkt wird passiert, dann darf es höchstens eine eingehende und höchstens eine ausgehende Kante geben an dem Punkt, damit es keine Überschneidungen gibt, wodurch gilt:
\begin{equation}
    aggregated\_flow \leq 2
    \tag{5}
\end{equation} 
\section{Implementierung des ILP-Modells}
Für die Implementierung des ILP-Modells wurde bewusst Python als Programmiersprache gewählt, obwohl in Bezug auf reine Rechenleistung Low-Level-Sprachen wie C oder C++ potenziell schnellere Ausführungszeiten bieten. In Python liegt der Fokus vielmehr auf einer hohen Lesbarkeit des Codes und der Flexibilität, die es ermöglicht, das Modell unkompliziert zu erweitern und zu modifizieren. Ein weiterer Vorteil ist der einfache Zugriff auf eine Vielzahl etablierter Libraries, die den Entwicklungsprozess erheblich vereinfachen. Besonders hervorzuheben ist hierbei die von Gurobi bereitgestellte Library gurobipy, die es ermöglicht auf leistungsfähige Optimierungsalgorithmen direkt aus Python heraus zuzugreifen. \newline
Gurobi zählt zu den führenden kommerziellen Solvern im Bereich der linearen Programmierung und der gemischt-ganzzahligen Optimierung. Der Solver kombiniert unter anderem das Simplex-Verfahren, Branch-and-Bound-Ansätze und Innere-Punkte-Methoden, um sowohl kleine als auch sehr große und komplexe Modelle effizient zu lösen. Gurobi ist zudem dafür bekannt, dass er fortschrittliche Features wie paralleles Rechnen und spezialisierte Heuristiken einsetzt, um den Lösungsprozess zu beschleunigen und gleichzeitig stabile und präzise Ergebnisse zu liefern \cite{Gurobi2025}. Die Integration in Python über die gurobipy-API macht es möglich, dass der gesamte Modellaufbau – von der Definition der Variablen und Nebenbedingungen bis hin zur Auswertung der Lösung – in einer Sprache erfolgt. Dies trägt erheblich dazu bei, dass das Modell nicht nur leistungsfähig, sondern auch gut nachvollziehbar und einfach zu testen und anzupassen ist.\newline
Die Entscheidung für Gurobipy als Schnittstelle zu Gurobi wurde zusätzlich durch aktuelle Vergleichsstudien untermauert. Eine neuere Studie, die fünf verschiedene LP-Solver vergleicht, bewertet Gurobi als einen der leistungsstärksten und zuverlässigsten Solver, was insbesondere für anspruchsvolle und große Optimierungsprobleme von zentraler Bedeutung ist \cite{Gurobi}. Diese Ergebnisse rechtfertigen den Einsatz von Gurobi in dieser Arbeit, da sie sowohl die Effizienz als auch die Stabilität der Modellierung und Lösung sicherstellen. Insgesamt ermöglicht die Wahl von Python in Kombination mit gurobipy einen schnellen Prototypenbau und eine übersichtliche Implementierung, wodurch nicht nur die Entwicklung und Durchführung umfangreicher Testreihen vereinfacht werden, sondern auch eine fundierte Analyse und spätere Erweiterung des Modells innerhalb des Forschungsprojekts gewährleistet ist.


\chapter{Experimente und Evaluation}
\section{Versuchsaufbau und Testfälle}
Für die Durchführung der Experimente und Testreihen wurde das Modell auf einer Maschine mit den in Tabelle~\ref{tab:spezifikationen} aufgeführten Hard- und Softwarekomponenten ausgeführt.
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Komponente}         & \textbf{Spezifikation} \\
        \hline
        Prozessor                   & Intel Xeon Gold 6342 @ 2.80GHz \\
        \hline
        Speicher (RAM)              & 235 GB DDR4 \\
        \hline
        Festplattenspeicher         & 50 GB SSD (System), 2 TB HDD/SSD (Daten) \\
        \hline
        Betriebssystem              &  Ubuntu 22.04.5 LTS x86\_64 \\
        \hline
        Programmiersprachen         & Python 3.10.12 \\
        \hline
    \end{tabular}
    \caption{Spezifikationen der verwendeten Testumgebung}
    \label{tab:spezifikationen}
\end{table}
Für die experimentelle Evaluierung des entwickelten ILP-Modells wurden verschiedene Testfälle konzipiert, die unterschiedliche Aspekte der Modellleistung beleuchten. Zunächst wurde ein Test entworfen, bei dem die Anzahl der Knoten sukzessive erhöht wird, um den Einfluss der Problemgröße auf die Laufzeit, die Anzahl der Variablen und die Komplexität des Modells zu untersuchen. Dabei wird die Knotenzahl von 5 bis 11 gestaffelt, und für jede Knotenzahl werden 10 zufällig generierte Instanzen betrachtet. Diese Zufallsexemplare werden mittels eines Python-Skripts erzeugt, wobei für jede Instanz die Knoten zufällig sortiert werden, um unterschiedliche Pfadkonstellationen zu simulieren. Die Gittergröße wird hierbei dynamisch angepasst – jeweils auf $(\left\lceil n/2 \right\rceil+1 \times \left\lceil n/2 \right\rceil+1),$ wobei $n$ die aktuelle Anzahl der Knoten darstellt – um ausreichend Platz zu bieten, ohne das Modell unnötig zu erweitern.\newline
Ein weiterer Testfall dient der Untersuchung, wie sich die Überlappung der beiden Pfade – gemessen an der Anzahl gemeinsamer adjazenter Knoten – auf die Laufzeit des Modells auswirkt. Für diesen Test wird die Knotenzahl konstant auf 10 festgelegt, ebenso die Gittergröße, welche auf $(6 \times 6)$ fixiert ist. Es werden jeweils 10 Testfälle erzeugt, bei denen die beiden Pfade genau $x$ gemeinsame adjazente Knoten besitzen. Der Wert $x$ variiert dabei sukzessive, beginnend bei 9 gleichen adjazenten Knoten (also vollständige Überlappung) bis hin zu 0 gleichen adjazenten Knoten (völlig disjunkte Pfade). Ein eigens entwickeltes Python-Skript gewährleistet dabei die Einhaltung der gewünschten Anzahl gemeinsamer adjazenter Knoten zwischen den Pfaden. Durch diese systematische Variation kann gezielt analysiert werden, ob und in welchem Ausmaß sich der Grad der strukturellen Überlappung auf die Lösungsdauer des Modells auswirkt. Die Pfade selbst werden dabei zufällig generiert, wobei das Skript sicherstellt, dass die vorgegebene Anzahl an Überschneidungen exakt eingehalten wird.
\newline
Bereits in vorangegangenen Tests konnte beobachtet werden, dass das Modell grundsätzlich korrekt arbeitet. Allerdings ergaben diese, dass die Laufzeiten sehr schnell mit zunehmender Knotenzahl ansteigen. Insbesondere bei Instanzen mit mehr als 11 Knoten würden, je nach Komplexität der Pfade, rechenintensive Berechnungen mehrere Tage in Anspruch nehmen – was angesichts der vorgegebenen Zeitressourcen für die im Rahmen dieser Arbeit nicht realisierbar ist. Deshalb wurde der erste Testabschnitt bewusst auf bis zu 11 Knoten begrenzt.\newline
Diese experimentellen Testfälle ermöglichen es, sowohl die Skalierung des Modells als auch den Einfluss der Pfadkomplexität detailliert zu analysieren. Die gewonnenen Erkenntnisse fließen in die spätere Bewertung der Effizienz und Praxistauglichkeit des Optimierungsansatzes ein.

\section{Auswertung der Ergebnisse}
In dieser Sektion werden die im Rahmen der experimentellen Evaluation gewonnenen Daten systematisch ausgewertet und analysiert. Ziel ist es, Zusammenhänge zwischen verschiedenen Einflussfaktoren - wie Laufzeit, Modellkomplexität, Pfadüberlappung - zu identifizieren und zu bewerten.  Zur Visualisierung der Ergebnisse werden unterschiedliche Diagrammtypen verwendet. Liniendiagramme kommen zum Einsatz, um Mittelwert- und Medianverläufe über verschiedene Testfallgruppen darzustellen und mögliche Korrelationen (oder das Fehlen einer Korrelation) zwischen Metriken wie Laufzeit und Objektivwert aufzuzeigen, während Violinplots genutzt werden, um die Streuung und Verteilung einzelner Metriken zu untersuchen. Als Objektivwert wird die Anzahl der genutzten Gitterkanten betrachtet, die dem Wert der Zielfunktion zugeordnet sind\newline
Ein besonderes Augenmerk liegt auf der Frage, inwiefern die Struktur der Pfade, wie etwa die Anzahl gemeinsamer Kanten oder die Anzahl adjazenter Knoten, sowie die Komplexität der resultierenden Einbettung Einfluss auf die Rechenzeit nehmen. Durch die Kombination dieser verschiedenen Visualisierung wird angestrebt, sowohl zentrale Tendenzen als auch Ausreißer und Verteilungseffekte sichtbar zu machen.\newline
Die nachfolgenden Abschnitte gliedern sich entsprechend der zuvor beschriebenen Testfälle
und betrachten zunächst den Einfluss  der Knotenzahl auf die Modellperformance. Im Anschluss werden die Auswirkungen unterschiedlicher Pfadüberlappungen detailliert analysiert.\newline

Im ersten Schritt der Analyse wird die Entwicklung der Modellkomplexität in Bezug auf zwei zentrale Metriken - die Anzahl der erzeugten Variablen und die Anzahl der formulierten Nebenbedingungen – betrachtet. Diese Größe hat direkten Einfluss auf die Rechenzeit des Solvers. Um diesen Zusammenhang zu illustrieren, wurden zwei verschiedene Perspektiven visualisiert: einerseits in Abhängigkeit von der Gittergröße bei konstanter Knotenzahl (Abbildung \ref{fig:var_grid}), andererseits in Abhängigkeit der Knotenzahl bei fixer Gittergröße (Abbildung \ref{fig:var_nodes}).\newline 
Abbildung \ref{fig:var_grid} zeigt deutlich, dass sowohl die Anzahl der Variablen als auch die Nebenbedingungen nicht linear, sondern vielmehr überproportional mit zunehmender Gittergröße ansteigen. Besonders auffällig ist der quadratische Zuwachs der Nebenbedingungen, was sich durch die Vielzahl an Restriktionen zur Platzierung, Pfadführung und Kantenverwendung erklären lässt. Während sich die Variablenanzahl zunächst vergleichsweise moderat entwickelt, wird mit wachsendem Gitter auch hier ein zunehmend steiler Anstieg beobachtet.\newline
In Abbildung \ref{fig:var_nodes} wird der Einfluss der Knotenzahl bei gleichbleibender Gittergröße (in diesem Fall $10 \times 10$) untersucht. Hier lässt sich ein fast linearer Zusammenhang erkennen: Sowohl die Anzahl der Variablen als auch die Nebenbedingungen steigen mit wachsender Knotenzahl kontinuierlich an. Dieser Befund ist konsistent mit der Tatsache, dass mit jedem weiteren Knoten zusätzliche Platzierungsvariablen erforderlich sind.\newline 
Diese Beobachtungen verdeutlichen die Notwendigkeit einer Beschränkung der Testfälle hinsichtlich Knotenzahl und Gittergröße, da die Modellgröße andernfalls schnell in einem Bereich liegt, der selbst für leistungsfähige Solver wie Gurobi nicht mehr effizient lösbar ist. Entsprechende Einschränkungen wurden daher in der Versuchsplanung berücksichtigt.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/20NodesVarNEb.png}
    \caption{Anzahl Variablen und Nebenbedingungen bei 20 Knoten in verschiedenen Gittergrößen}
    \label{fig:var_grid}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/VariabelConstrains5-11.png}
    \caption{Anzahl der Variablen und Nebenbedingungen in Abhängigkeit von der Knotenzahl bei fester Gittergröße ($10 \times 10$)}
    \label{fig:var_nodes}
\end{figure}
Um zu Veranschaulichen, wie die Laufzeit des Modells in Abhängigkeit von der Gittergröße beeinflusst wird, wurden 10 Testfälle mit identischer Knotenzahl (8 Knoten) sowohl auf einem $(5\times 5)-$Gitter als auch auf einem $(8\times8)-$Gitter ausgeführt. Die Ergebnisse in Abbildung \ref{fig:SekNode8} zeigen einen klaren Anstieg der Rechenzeit bei größerem Gitter. Während die Laufzeiten im $(5\times 5)-$Gitter relativ konstant und niedrig blieben - mit Werten im Bereich von ca. 4 bis 7,7 Sekunden - stiegen sie im $(8\times 8)-$Gitter signifikant an und zeigten zudem eine deutlich höhere Varianz. Die Laufzeiten lagen hier zwischen rund 39 und 494 Sekunden. Diese Schwankungen deuten darauf hin, dass die Lösungsdauer stark von der konkreten Struktur der generierten Testfälle abhängt, sobald die Komplexität der möglichen Pfadanordnungen innerhalb des Gitters zunimmt. Gleichzeitig unterstreicht dieses Verhalten die Sensitivität des ILP-Modells gegenüber der Gittergröße, was insbesondere bei wachsender Problemgröße ein limitierender Faktor für die praktische Anwendbarkeit darstellt. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/Laufzeit8NodesDiffOneY.png}
    \caption{Vergleich der Laufzeiten bei 8 Knoten mit unterschiedlicher Gittergröße (5$\times$5 vs. 8$\times$8)}
    \label{fig:SekNode8}
\end{figure}
Ein sinnvoller Ansatz zur Analyse der Rechenzeiten besteht im parallelen Vergleich von Durchschnitts- und Medianwerten. Während der Durchschnitt einen globalen Mittelwert der Laufzeiten darstellt, gibt der Median Aufschluss über die zentrale Tendenz, ohne von Ausreißern beeinflusst zu werden. Der Vergleich beider Werte erlaubt somit Rückschlüsse auf die Streuung innerhalb der Testfälle und hilft dabei die Robustheit der Modelllaufzeiten unter verschiedenen Bedingungen zu beurteilen. \newline
Die Ergebnisse für Knotenzahlen von 5 bis 8 (vgl. Abbildung \ref{fig:Median5}) zeigen, dass sich Durchschnitts- und Medianwerte in allen betrachteten Testfällen sehr nahe liegen. So liegen die Mittelwerte bei 0,15 s (5 Knoten), 0,47 s (6 Knoten), 1,82 s (7 Knoten) und 5,09 s (8 Knoten), während die Mediane mit 0,15 s, 0,48 s, 1,80 s und 4,99 s nahezu identisch sind. Diese enge Übereinstimmung weist auf eine relativ homogene Verteilung der Laufzeiten innerhalb dieser Gruppe hin, ohne das Auftreten signifikanter Ausreißer. Die Komplexität der generierten Instanzen scheint in diesem Bereich noch ausreichend beherrschbar, sodass das Modell konsistente Laufzeiten erzielt.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/Mean_Medain5-8.png}
    \caption{Vergleich von Mittelwert und Median der Laufzeiten für Knotenzahlen 5 bis 8.}
    \label{fig:Median5}
\end{figure}
Ein anderes Bild ergibt sich jedoch bei höheren Knotenzahlen von 9 bis 11. (vgl. Abbildung \ref{fig:Median9}). \newline
Es ist zunächst eine kontinuierliche Zunahme der mittleren Laufzeit zu beobachten: Der Mittelwert steigt von etwas 24,36 Sekunden bei 9 Knoten über 43,54 Sekunden bei 10 Knoten auf beachtliche 4104,22 Sekunden bei 11 Knoten. Auch die Medianwerte spiegeln diesen Anstieg wider - sie liegen bei 37,75, 86,49 und 4129,85 Sekunden. Auffällig ist allerdings, dass sich bei 11 Knoten Median und Mittelwert fast exakt entsprechen. Dies könnte auf eine gleichmäßige Verteilung der Laufzeiten hinweisen - doch ein Blick auf die zugehörige Verteilung in Abbildung \ref{fig:Violin} widerlegt diese Annahme.\newline
Der Violinplot für 11 Knoten zeigt eine extreme Streuung der Laufzeiten: Sie reichen von sehr kurzen Laufzeiten unter 200 Sekunden (z.B. 167,68 s und 163,75 s) bis hin zu Ausreißern im hohen vierstelligen und fünfstelligen Bereichen (z.B. 8090,48 s und 11551,85 s). Diese deutliche Heterogenität innerhalb der Testfälle wird durch die symmetrischen Mittel- und Medianwerte verschleiert. Der Violinplot offenbart damit ein wesentlich realistischeres Bild der Komplexitätsunterschiede, die durch zufällig generierte Pfadstrukturen bei gleicher Knotenzahl entstehen können. \newline 
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Mean_Medain9-11.png}
        \captionof{figure}{Mittelwert- und Medianvergleich der Laufzeiten für Knotenzahlen 9 bis 11.}
        \label{fig:Median9}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/11NodesViolinplot.png}
        \captionof{figure}{Verteilung der Laufzeiten für Testfälle mit 11 Knoten.}
        \label{fig:Violin}
    \end{minipage}
\end{figure}
Diese Analyse unterstreicht die Notwendigkeit, bei der Bewertung von Modellergebnissen nicht ausschließlich auf zentrale Kennwerte zu vertrauen, sondern stets auch die zugrunde liegende Verteilung zu betrachten.\newline 
Im folgenden Abschnitt wird untersucht, welche Faktoren für die unterschiedlichen Laufzeiten der Testfälle mit 10 Knoten verantwortlich sind. Zu diesem Zweck werden die Objektivwerte und die Anzahl gleicher adjazenter Knoten als mögliche Einflussfaktoren betrachtet, um mögliche Korrelationen zu den beobachteten Laufzeiten zu identifizieren.\newline 
Die erste Abbildung \ref{fig:LaufObj}, welche die Laufzeiten im Vergleich zu den Objektivwerten zeigt, lässt keine klare Korrelation erkennen. Zwar zeigen einige Testfälle ähnliche Objektivwerte, jedoch weichen ihre Laufzeiten stark voneinander ab. Ein markantes Beispiel hierfür sind die Testfälle 4 und 6 mit den Objektivwerten 28 , die Laufzeiten von 45,44 Sekunden bzw. 145,99 Sekunden aufwiesen. Diese deutliche Varianz in den Laufzeiten trotz identischer Objektivwerte lässt darauf schließen, dass der Objektivwert allein keinen verlässlichen Rückschluss auf die Laufzeit zulässt.\newline 
Auch die zweite Abbildung \ref{fig:LaufAdj}, die die Laufzeit im Verhältnis zur Anzahl gleicher adjazenter Knoten darstellt, zeigt keinen eindeutigen Zusammenhang. Der Testfall 3 und 7 mit jeweils 3 gleichen adjazenten Knoten haben  eine Laufzeit von 31,22 Sekunden bzw. 231,68 Sekunden. Diese Schwankungen lassen darauf schließen, dass die Anzahl gleicher Knoten keinen signifikanten Einfluss auf die Laufzeit hat.
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/LaufzeitObjektivwert10.png}
        \captionof{figure}{Vergleich von Laufzeiten mit Objektivwert für Knotenzahl 10.}
        \label{fig:LaufObj}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/LaufzeitAdjNodes10.png}
        \captionof{figure}{Vergleich von Laufzeiten mit der Anzahl gleicher adjazenter Knoten für Knotenzahl 10.}
        \label{fig:LaufAdj}
    \end{minipage}
\end{figure}
Insgesamt zeigen die Auswertungen, dass weder die Objektivwerte noch die Anzahl der gleichen adjazenter Knoten in einer eindeutigen Korrelation zu den Laufzeiten stehen. Die starke Streuung der Laufzeiten, selbst bei ähnlichen Werten in den untersuchten Parametern, deutet darauf hin, dass andere, bisher nicht berücksichtigte Faktoren einen größeren Einfluss auf die Laufzeit haben könnten.\newline 
Um ein besseres Verständnis der großen Laufzeitunterschiede zwischen den einzelnen Testfällen zu gewinnen, werden im Folgenden vier ausgewählte Testfälle - nämlich 3,4,6 und 7 - im Detail betrachtet. Abbildung \ref{fig:gesamtabbildung} zeigt die resultierenden Einbettungen dieser Fälle. Die Auswahl basiert auf der zuvor festgestellten Streuung in den Laufzeiten trotz ähnlicher Objektivwerte und gleicher Anzahl gemeinsamer adjazenter Knoten. Durch die Analyse der finalen Einbettungen wird deutlich, dass insbesondere die Länge der Kanten, die mehr als eine Gitterkante nutzen und  die Anzahl dieser im resultierenden Graphen eine entscheidende Rolle für die Laufzeit spielen könnten.\newline 
Ein Vergleich der Graphen aus Abbildung \ref{fig:gesamtabbildung}. verdeutlicht diesen Zusammenhang: Testfall 3 (Abbildung \ref{fig:teilbild_a}) weist eine Laufzeit von nur 31,22 Sekunden auf und enthält lediglich zwei Kanten der Länge 2 sowie eine einzige Kante der Länge 6. Testfall 4 (Abbildung~\ref{fig:teilbild_b}) zeigt mit fünf Kanten der Länge 2, einer Kante der Länge 3 und einer weiteren der Länge 6 bereits eine leicht erhöhte Komplexität und resultiert in einer Laufzeit von 45,44 Sekunden. Deutlich komplexer gestaltet sich die Einbettung bei Testfall 6 (Abbildung \ref{fig:teilbild_c}), mit mehreren Kanten höherer Länge – insbesondere zwei Kanten der Länge 3 sowie zwei der Länge 4 – was sich in einer Laufzeit von 145,99 Sekunden widerspiegelt. Noch ausgeprägter ist dieser Effekt bei Testfall 7 (Abbildung \ref{fig:teilbild_d}): Hier kommen zusätzlich zur vorherigen Struktur erneut längere Kanten hinzu, was zu einer nochmals erhöhten Laufzeit von 231,68 Sekunden führt.
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Testfall3.pdf}
        \caption{Testfall 3}
        \label{fig:teilbild_a}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Testfall4.pdf}
        \caption{Testfall 4}
        \label{fig:teilbild_b}
    \end{subfigure}
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Testfall6.pdf}
        \caption{Testfall 6}
        \label{fig:teilbild_c}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Testfall7.pdf}
        \caption{Testfall 7}
        \label{fig:teilbild_d}
    \end{subfigure}
    \hfill
    \caption{Graphische Darstellung der vier Testfälle.}
    \label{fig:gesamtabbildung}
\end{figure}


Diese Beobachtungen legen nahe, dass nicht die Anzahl der verwendeten Gitterkanten, sondern insbesondere die Anzahl längerer Kanten – also solcher mit einer Länge größer als 1 – maßgeblichen Einfluss auf die benötigte Rechenzeit hat. Die resultierende Einbettungskomplexität erweist sich damit als zentraler Einflussfaktor auf die Laufzeit, was durch die zusätzliche Übersicht in Tabelle \ref{tab:tabpa} über alle Testfälle mit Knotenzahl 10 gestützt wird.\newline 
Insgesamt zeigt sich, dass die Laufzeit nicht durch aggregierte Merkmale wie Objektivwert oder Knoteneigenschaften erklärbar ist, sondern vielmehr durch die konkrete geometrische Ausprägung der Pfade im Gitter beeinflusst wird. Die Komplexität der Einbettung selbst – insbesondere gemessen an der Anzahl und Länge von Kanten, die mehrere Gitterkanten nutzen – steht somit in klarer Korrelation zur benötigten Rechenzeit.\newline 


\begin{longtable}{|c|c|c|}
\caption{Laufzeiten und Pfadlängenverteilung für alle 10 Testfälle mit 10 Knoten.} \label{tab:tabpa} \\
\hline
\textbf{Testfall} & \textbf{Laufzeit (Sekunden)} & \textbf{Kanten (Länge:Anzahl)} \\
\hline
\endfirsthead

\hline
\textbf{Testfall} & \textbf{Laufzeit (Sekunden)} & \textbf{Kanten (Länge:Anzahl)} \\
\hline
\endhead

\hline
\multicolumn{3}{|r|}{\textit{Fortsetzung auf der nächsten Seite}} \\
\hline
\endfoot

\hline
\endlastfoot

1 & 41,6429 & 2:4, 3:1, 6:1 \\
2 & 128,4196 & 2:4, 3:1, 7:1 \\
3 & 31,2159 & 2:2, 6:1 \\
4 & 45,4415 & 2:5, 3:1, 6:1 \\
5 & 33,0605 & 2:3, 5:1 \\
6 & 145,9963 & 2:5, 3:2, 4:2 \\
7 & 231,6784 & 2:2, 3:1, 4:2, 6:1 \\
8 & 136,9107 & 2:2, 3:1, 4:3 \\
9 & 39,9753 & 2:4, 3:2 \\
10 & 30,6745 & 2:3, 3:2 \\
\end{longtable}

Im abschließenden Auswertungsschritt wurde untersucht, welchen Einfluss die Anzahl gleicher adjazenter Knotenpaare auf die Laufzeit hat. Hierfür wurden jeweils 10 Testfälle mit 10 Knoten generiert, wobei die Anzahl identischer adjazenter Knoten systematisch von 0 bis 9 variiert wurde. Aus den resultierenden Laufzeiten wurden anschließend der Mittelwert und der Median berechnet (vgl. Abbildung \ref{fig:Sim}).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/SimMeanMedian.png}
    \caption{Vergleich der Laufzeiten bei 8 Knoten mit unterschiedlicher Gittergröße (5$\times$5 vs. 8$\times$8)}
    \label{fig:Sim}
\end{figure}
Die Ergebnisse zeigen einen insgesamt abnehmenden Trend beider Kennwerte mit zunehmender Anzahl gemeinsamer Knoten: Der Mittelwert fällt von über 1000 Sekunden bei 0 gleichen Knoten kontinuierlich bis auf etwa 5,6 Sekunden bei 9 gleichen Knoten. Ein ähnliches Bild zeigt sich für den Median, der von rund 313 Sekunden auf knapp 5 Sekunden sinkt. Besonders auffällig ist, dass die Laufzeit für 9 gemeinsame Knoten auf ein Niveau absinkt, das vergleichbar mit den Ergebnissen bei 8 Knoten und einem $(5\times5)-$Gitter ist. Dies weist darauf hin, dass eine nahezu vollständige Pfadüberlappung zu sehr einfachen Einbettungen führt, die sich effizient berechnen lassen.\newline 
Gleichzeitig ist zu beobachten, dass die Laufzeiten bei niedrigen Überlappungen – insbesondere bei 0 und 1 gemeinsamen Knoten – stark streuen. Dies lässt sich dadurch erklären, dass bei geringen strukturellen Gemeinsamkeiten keine simplen Teilstrukturen genutzt werden können, um die Pfade effizient im Gitter unterzubringen. Stattdessen entstehen komplexere Konstellationen mit potenziell längeren Kanten und ungünstigerem Platzbedarf, was wiederum zu erhöhten und stark schwankenden Rechenzeiten führt.\newline 
Obwohl die Korrelation zwischen der Anzahl gleicher Knoten und der Laufzeit nicht perfekt linear ist, zeigt sich eine klare Tendenz: Höhere strukturelle Überlappungen fördern die Entstehung einfacher, symmetrischer Einbettungen, die sich schnell lösen lassen. Geringe Überlappungen hingegen führen mit höherer Wahrscheinlichkeit zu komplexen Resultaten mit entsprechend längeren Laufzeiten.


\section{Diskussion der Ergebnisse}
Die durchgeführten Experimente zeigen deutlich, dass das entwickelte Modell für kleinere Eingaben äußerst effizient arbeitet. Bei moderaten Knotenzahlen und kompakten Gittergrößen lassen sich selbst mehrere zufällig generierte Testfälle in sehr kurzer Zeit lösen. Das Modell liefert dabei konsistente Ergebnisse mit stabilen Laufzeiten, was auf eine robuste Formulierung und effektive Lösbarkeit im kleineren Maßstab hinweist.\newline 
Mit zunehmender Komplexität der Eingabeinstanzen – insbesondere bei wachsender Knotenzahl und entsprechend erforderlicher Gittervergrößerung – steigt die Rechenzeit jedoch stark an. Die Auswertungen belegen, dass dieser Anstieg nicht nur auf die wachsende Modellgröße (in Form von Variablen und Nebenbedingungen) zurückzuführen ist, sondern auch auf die strukturelle Komplexität der resultierenden Einbettung. Größere Knotenanzahlen erhöhen die Wahrscheinlichkeit für komplexe Pfadverläufe und lange Kanten, wodurch die Lösungsfindung erheblich erschwert wird.\newline 
Ab einer bestimmten Problemgröße, insbesondere jenseits von 10 bis 12 Knoten, ist das Modell nicht mehr in vertretbarer Zeit lösbar. Die Laufzeit wächst sehr schnell und macht eine Anwendung für größere Instanzen im Praxiseinsatz aktuell nicht realistisch. Insgesamt lässt sich festhalten, dass das Modell zwar korrekt funktioniert und konsistente Ergebnisse liefert, jedoch in seiner derzeitigen Form nicht für großskalige Probleme skaliert.


\chapter{Fazit und Ausblick}
Die experimentellen Ergebnisse haben gezeigt, dass das Modell für kleine Instanzgrößen zuverlässige und schnelle Ergebnisse liefert. Besonders bei Knotenzahlen bis etwa 8 und entsprechend klein gewählten Gittergrößen gelingt es, selbst komplexere Testfälle innerhalb weniger Sekunden zu lösen. Die Laufzeiten sind dabei stabil und gut prognostizierbar. Ab einer Knotenzahl von etwa 12 hingegen steigt die Rechenzeit drastisch an – teils bis in den Stunden- oder gar Tagesbereich. In diesen Fällen ist das Modell in der aktuellen Form nicht mehr praxistauglich. Die Ursache liegt sowohl in der wachsenden Modellgröße durch größere Gitter (mehr Variablen und Nebenbedingungen), als auch in der gestiegenen strukturellen Komplexität der resultierenden Einbettung, die durch überlappende und lange Pfade entsteht.\newline 
Diese Beobachtungen machen deutlich, dass das Modell zwar konzeptionell korrekt arbeitet, aber in seiner jetzigen Form nicht ausreichend skaliert, um größere Probleminstanzen effizient zu lösen.\newline
Um die praktische Anwendbarkeit des Modells zu verbessern, bieten sich verschiedene Optimierungsansätze an. Eine vielversprechende Alternative zur exakten Modellierung stellen heuristische  Verfahren dar, wie etwa Greedy-Ansätze oder Simulated Annealing. Mit ihnen lassen sich in akzeptabler Zeit gute Näherungslösungen für größere Instanzen finden. Diese Lösungen können als obere Schranke für das exakte Modell dienen: Kennt man bereits eine gültige, aber nicht optimale Einbettung mit bekanntem Zielfunktionswert, so lassen sich während der Lösungssuche alle Zwischenlösungen verwerfen, deren Kosten diese Schranke überschreiten. Dadurch kann der Suchraum deutlich eingeschränkt und die Laufzeit reduziert werden. Ergänzend hierzu bieten sich Verfahren der Problemvorverarbeitung an, um die Eingabeinstanz bereits vor der eigentlichen Modelllösung effizient zu vereinfachen. Durch gezielte Graphvereinfachung, Symmetrieerkennung oder Clustering lassen sich unnötige Redundanzen im Gittermodell vorab eliminieren und die Rechenzeit deutlich senken.\newline
Ein weiterer Vorteil des entwickelten Modells liegt in seiner Flexibilität. Die Grundstruktur lässt sich relativ leicht auf andere Anwendungsfälle übertragen oder erweitern. So könnten beispielsweise statt zwei auch drei oder mehr Hamiltonpfade betrachtet werden, um komplexere Szenarien abzubilden. Ebenso wären spezielle Einbettungsanforderungen denkbar – etwa das Erzwingen bestimmter Teilstrukturen, symmetrischer Verläufe oder die Minimierung von Kantenüberschneidungen. Die zugrunde liegende Formulierung ist dabei modular genug aufgebaut, um solche Anpassungen mit vertretbarem Aufwand zu realisieren.\newline 
Für künftige Arbeiten bietet sich die systematische Untersuchung dieser Erweiterungs- und Optimierungsmöglichkeiten an. Ziel könnte ein hybrider Ansatz sein, der exakte Modellierung für kleine Teilprobleme mit heuristischen Strategien für die Gesamtlösung kombiniert. Ebenso wäre eine Integration von Lernkomponenten (z.,B. zur Abschätzung der Gittergröße oder zur Vorhersage problematischer Instanzen) denkbar, um den Rechenaufwand frühzeitig abschätzen und steuern zu können.\newline 
Insgesamt zeigt die Arbeit, dass das entwickelte Modell eine solide Grundlage bietet, um strukturierte Mehrpfadeinbettungen zu formulieren und zu lösen – sofern die Instanzgröße dies zulässt. Die Erweiterung in Richtung Skalierbarkeit, Flexibilität und Praxistauglichkeit bleibt ein zentrales Ziel weiterer Forschung.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\bibliographystyle{mybabalpha-fl}
\bibliography{mybib}

\end{document}